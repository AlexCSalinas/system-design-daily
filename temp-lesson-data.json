{"lesson":{"day":5,"topic":"Message Queues","title":"Asynchronous Communication Patterns","summary":"Message queues enable asynchronous communication between services, improving system resilience and scalability.","key_concepts":["Producer-Consumer","Pub-Sub","Dead Letter Queues","Message Ordering"],"real_world_example":"Uber uses Apache Kafka to handle real-time location updates and trip matching across their platform","mermaid_diagram":"graph LR\n    Producer --> Queue[Message Queue]\n    Queue --> Consumer1[Consumer 1]\n    Queue --> Consumer2[Consumer 2]\n    Queue --> Consumer3[Consumer 3]","discussion_questions":["How would you ensure message ordering in a distributed queue system?","When would you choose RabbitMQ over Apache Kafka?"],"quiz":[{"question":"What happens to messages that cannot be processed in a queue system?","options":["They are deleted","Sent to dead letter queue","Retried indefinitely","Stored in database"],"correct":1}]},"date":"2025-10-12","lessonIndex":4}